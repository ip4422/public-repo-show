{"version":3,"sources":["store/repos/types.ts","components/RepoCard/RepoCard.tsx","components/Breadcrumbs/Breadcrumbs.tsx","config/constants.ts","components/Breadcrumbs/BreadcrumbsContainer.tsx","store/repos/reposActions.ts","store/repos/reposSlice.ts","utils/hooks.ts","pages/RepoList/RepoList.tsx","pages/RepoList/RepoListContainer.tsx","pages/Repo/Repo.tsx","pages/Repo/RepoItem.tsx","config/routes.tsx","pages/Repo/RepoContainer.tsx","helpers/routerHelpers.ts","components/Header/HeaderContainer.tsx","components/Header/Header.tsx","app/App.tsx","app/Routes.tsx","app/store.ts","index.tsx"],"names":["LoadingStatus","RepoContetItemType","Title","Typography","Text","RepoCard","props","name","description","link","bordered","style","width","level","to","Breadcrumbs","items","color","length","map","item","Item","href","title","ROOT_PATH","BreadcrumbsContainer","useState","setItems","location","useLocation","useEffect","pathes","pathname","split","filter","pointer","breadcrumbsItems","shift","path","i","push","fetchRepos","createAsyncThunk","userName","a","rejectWithValue","fetch","response","status","json","repos","message","fetchRepoContent","repoName","repoContent","fetchRepoReadme","repoReadme","initialState","reposLoading","idle","repoLoading","readmeLoading","createSlice","reducers","extraReducers","builder","addCase","pending","state","fulfilled","action","succeeded","payload","rejected","error","failed","atob","content","reducer","useAppDispatch","useDispatch","useAppSelector","useSelector","RepoList","loading","tip","spinning","repo","full_name","RepoListContainer","Repo","header","readme","size","dataSource","renderItem","className","children","RepoItem","type","Meta","avatar","dir","FolderFilled","fontSize","FileOutlined","REPOS_ROOT_KEY","REPO_PAGE_KEY","ROUTES","key","exact","component","dispatch","useParams","userId","repoId","userIdPath","find","route","repoIdPath","allRoutesToList","HeaderContainer","searchValue","setSearchValue","history","useHistory","matchPath","params","undefined","getRouteParams","onSearch","value","onChange","event","target","Header","justify","align","gutter","span","GithubOutlined","display","Search","placeholder","App","minHeight","Content","padding","routes","Footer","textAlign","position","bottom","RouteWithSubRoutes","render","ApplicationRoutes","store","configureStore","devTools","ReactDOM","StrictMode","document","getElementById"],"mappings":"+NAcYA,EAOAC,E,qGCHJC,EAAgBC,IAAhBD,MAAOE,EAASD,IAATC,KAKFC,EAAW,SAACC,GACvB,MAAmDA,EAA3CC,YAAR,MAAe,GAAf,IAAmDD,EAAhCE,mBAAnB,MAAiC,GAAjC,IAAmDF,EAAdG,YAArC,MAA4C,GAA5C,EACA,OACE,eAAC,IAAD,CAAMC,UAAU,EAAOC,MAAO,CAAEC,MAAO,QAAvC,UACE,cAACV,EAAD,CAAOW,MAAO,EAAd,SACE,cAAC,IAAD,CAAMC,GAAIL,EAAV,SAAiBF,MAEnB,cAACH,EAAD,UAAOI,IACP,cAAC,IAAD,Q,SCPOO,EAAc,SAAC,GAA8C,IAA5CC,EAA2C,EAA3CA,MAC5B,OACE,cAAC,IAAD,CAAYL,MAAO,CAAEM,MAAO,QAA5B,SACGD,EAAME,QACLF,EAAMG,KAAI,SAAAC,GAAI,OACZ,cAAC,IAAWC,KAAZ,UACE,cAAC,IAAD,CAAMP,GAAIM,EAAKE,KAAf,SAAsBF,EAAKG,SADPH,EAAKE,KAAOF,EAAKG,a,iBCpBpCC,EAAY,oBCCZC,EAAuB,WAClC,MAA0BC,mBAAS,IAAnC,mBAAOV,EAAP,KAAcW,EAAd,KACIC,EAAWC,cAwBf,OAtBAC,qBAAU,WACR,IAAMC,EAASH,EAASI,SAASC,MAAM,KAAKC,QAAO,SAAAd,GAAI,MAAa,KAATA,KACvDe,EAAU,EACRC,EAAsC,GAK5C,IAHiB,WAAIL,EAAOI,MAAeX,GACzCO,EAAOM,QAEFF,EAAUJ,EAAOb,QAAQ,CAE9B,IADA,IAAIoB,EAAmBd,EACde,EAAI,EAAGA,GAAKJ,EAASI,IAC5BD,GAAQ,IAAMP,EAAOQ,GAEvBH,EAAiBI,KAAK,CACpBlB,KAAMgB,EACNf,MAAOQ,EAAOI,KAEhBA,IAEFR,EAASS,KACR,CAACR,IAEG,cAAC,EAAD,CAAaZ,MAAOA,K,kCC1BhByB,EAAaC,YAOxB,oCAPwC,uCAQxC,WAAOC,EAAP,sBAAAC,EAAA,6DAAmBC,EAAnB,EAAmBA,gBAAnB,SACyBC,MAAM,gCAAD,OACMH,EADN,WAD9B,UAI0B,OAHlBI,EADR,QAIeC,OAJf,gCAKwBD,EAASE,OALjC,cAKUC,EALV,yBAMWA,GANX,mBAQSL,EART,UAQgCE,EAASE,OARzC,2BAQiDE,QARjD,8EARwC,yDA2B7BC,EAAmBV,YAO9B,0CAP8C,uCAQ9C,uCAAAE,EAAA,6DAASD,EAAT,EAASA,SAAUU,EAAnB,EAAmBA,SAAcR,EAAjC,EAAiCA,gBAAjC,SACyBC,MAAM,gCAAD,OACMH,EADN,YACkBU,EADlB,cAD9B,UAI0B,OAHlBN,EADR,QAIeC,OAJf,iCAK8BD,EAASE,OALvC,cAKUK,EALV,yBAMWA,GANX,oBAQST,EART,UAQgCE,EAASE,OARzC,2BAQiDE,QARjD,8EAR8C,yDA2BnCI,EAAkBb,YAO7B,yCAP6C,uCAQ7C,uCAAAE,EAAA,6DAASD,EAAT,EAASA,SAAUU,EAAnB,EAAmBA,SAAcR,EAAjC,EAAiCA,gBAAjC,SACyBC,MAAM,gCAAD,OACMH,EADN,YACkBU,EADlB,YAD9B,UAI0B,OAHlBN,EADR,QAIeC,OAJf,iCAK6BD,EAASE,OALtC,cAKUO,EALV,yBAMWA,GANX,oBAQSX,EART,UAQgCE,EAASE,OARzC,2BAQiDE,QARjD,8EAR6C,0D,SLlDnCnD,K,YAAAA,E,kBAAAA,E,sBAAAA,E,iBAAAA,M,cAOAC,K,UAAAA,E,aAAAA,M,KAqDL,I,IAAMwD,EAA2B,CACtCC,aAAc1D,EAAc2D,KAC5BC,YAAa5D,EAAc2D,KAC3BE,cAAe7D,EAAc2D,KAC7BT,MAAO,GACPI,YAAa,GACbE,WAAY,IMnBDN,EAzDQY,YAAY,CAC/BvD,KAAM,yBACNkD,eACAM,SAAU,GACVC,cAAe,SAAAC,GACbA,EAGGC,QAAQzB,EAAW0B,SAAS,SAAAC,GAC3BA,EAAMV,aAAe1D,EAAcmE,WAGpCD,QAAQzB,EAAW4B,WAAW,SAACD,EAAOE,GACrCF,EAAMV,aAAe1D,EAAcuE,UACnCH,EAAMlB,MAAQoB,EAAOE,SAAY,MAGlCN,QAAQzB,EAAWgC,UAAU,SAACL,EAAOE,GACpCF,EAAMM,OAAc,OAANJ,QAAM,IAANA,OAAA,EAAAA,EAAQE,UAAW,GACjCJ,EAAMlB,MAAQ,GACdkB,EAAMV,aAAe1D,EAAc2E,UAIpCT,QAAQd,EAAiBe,SAAS,SAAAC,GACjCA,EAAMR,YAAc5D,EAAcmE,WAGnCD,QAAQd,EAAiBiB,WAAW,SAACD,EAAOE,GAC3CF,EAAMR,YAAc5D,EAAcuE,UAClCH,EAAMd,YAAcgB,EAAOE,SAAY,MAGxCN,QAAQd,EAAiBqB,UAAU,SAACL,EAAOE,GAC1CF,EAAMM,OAAc,OAANJ,QAAM,IAANA,OAAA,EAAAA,EAAQE,UAAW,GACjCJ,EAAMd,YAAc,GACpBc,EAAMR,YAAc5D,EAAc2E,UAInCT,QAAQX,EAAgBY,SAAS,SAAAC,GAChCA,EAAMP,cAAgB7D,EAAcmE,WAGrCD,QAAQX,EAAgBc,WAAW,SAACD,EAAOE,GAC1CF,EAAMP,cAAgB7D,EAAcuE,UACpCH,EAAMZ,WAAaoB,KAAKN,EAAOE,QAAQK,SAAW,OAGnDX,QAAQX,EAAgBkB,UAAU,SAACL,EAAOE,GACzCF,EAAMM,OAAc,OAANJ,QAAM,IAANA,OAAA,EAAAA,EAAQE,UAAW,GACjCJ,EAAMZ,WAAa,GACnBY,EAAMP,cAAgB7D,EAAc2E,aAKVG,QCzDrBC,EAAiB,kBAAMC,eACvBC,EAAkDC,I,iBCgBlDC,EAAW,SAAC,GAGU,IAAD,IAFhCjC,aAEgC,MAFxB,GAEwB,MADhCkC,eACgC,SAChC,OACE,cAAC,IAAD,CAAMC,IAAI,aAAaC,SAAUF,EAAjC,SACGlC,EAAMhC,OACLgC,EAAM/B,KAAI,SAAAoE,GAAI,OACZ,cAAC,EAAD,CAEEhF,KAAMgF,EAAKhF,KACXE,KAAM8E,EAAKC,UACXhF,YAAa+E,EAAK/E,aAJpB,kBACkB+E,EAAKC,eAOzB,cAAC,IAAD,CAAOhF,YAAa,kDC5BfiF,EAAoB,WAC/B,IAAMvC,EAAQ+B,GAAe,SAAAb,GAAK,OAAIA,EAAMlB,MAAMA,OAAS,MACrDkC,EAAUH,GACd,SAAAb,GAAK,OACHA,EAAMlB,MAAMQ,eAAiB1D,EAAcmE,SAC3CC,EAAMlB,MAAMU,cAAgB5D,EAAcmE,SAC1CC,EAAMlB,MAAMW,gBAAkB7D,EAAcmE,WAGhD,OAAO,cAAC,EAAD,CAAUjB,MAAOA,EAAOkC,QAASA,K,mCCU7BM,G,OAAO,SAAC,GAKU,IAAD,IAJ5B1E,aAI4B,MAJpB,GAIoB,MAH5B2E,cAG4B,MAHnB,GAGmB,MAF5BC,cAE4B,MAFnB,GAEmB,MAD5BR,eAC4B,SAC5B,OACE,cAAC,IAAD,CAAMC,IAAI,aAAaC,SAAUF,EAAjC,SACGpE,EAAME,OACL,qCACE,cAAC,IAAD,CACE2E,KAAK,QACLF,OAAQ,cAAC,IAAWzF,MAAZ,CAAkBW,MAAO,EAAzB,SAA6B8E,IACrCjF,UAAQ,EACRoF,WAAY9E,EACZ+E,WAAY,SAAA3E,GAAI,OAAI,cAAC,EAAD,eAAcA,OAEpC,qBAAK4E,UAAU,eAAf,SACE,cAAC,IAAD,CAAMzE,MAAM,YAAZ,SACE,cAAC,IAAD,CAAe0E,SAAUL,WAK/B,cAAC,IAAD,CAAOpF,YAAa,mD,kBC3Cf0F,EAAW,SAAC,GAA8C,IAA5C3F,EAA2C,EAA3CA,KAAM4F,EAAqC,EAArCA,KAC/B,OACE,cAAC,IAAK9E,KAAN,UACE,cAAC,IAAKA,KAAK+E,KAAX,CACEC,OACEF,IAASlG,EAAmBqG,IAC1B,cAACC,EAAA,EAAD,CAAc5F,MAAO,CAAEM,MAAO,UAAWuF,SAAU,UAEnD,cAACC,EAAA,EAAD,CAAc9F,MAAO,CAAEM,MAAO,UAAWuF,SAAU,UAGvDhG,YAAaD,OChBRmG,EAAiB,iBACjBC,EAAgB,gBAkChBC,EAAsB,CACjC,CACEtE,KAAK,GAAD,OAAKd,EAAL,KACJqF,IAAK,WACLC,OAAO,EACPC,UAAWtB,GAEb,CACEnD,KAAK,GAAD,OAAKd,EAAL,YACJsF,OAAO,EACPD,IAAKH,EACLK,UAAWtB,GAEb,CACEnD,KAAK,GAAD,OAAKd,EAAL,oBACJsF,OAAO,EACPD,IAAKF,EACLI,UC3CyB,WAC3B,IAAMC,EAAWjC,IACX/D,EAAQiE,GACZ,SAAAb,GAAK,OAAIA,EAAMlB,MAAMI,aAAgB,MAEjC8B,EAAUH,GACd,SAAAb,GAAK,OACHA,EAAMlB,MAAMQ,eAAiB1D,EAAcmE,SAC3CC,EAAMlB,MAAMU,cAAgB5D,EAAcmE,SAC1CC,EAAMlB,MAAMW,gBAAkB7D,EAAcmE,WAE1CyB,EAASX,GAAe,SAAAb,GAAK,OAAIA,EAAMlB,MAAMM,YAAc,MACjE,EAAyByD,cAAnBC,EAAN,EAAMA,OAAQC,EAAd,EAAcA,OASd,OAPArF,qBAAU,WACJoF,GAAUC,IACZH,EAAS5D,EAAiB,CAAET,SAAUuE,EAAQ7D,SAAU8D,KACxDH,EAASzD,EAAgB,CAAEZ,SAAUuE,EAAQ7D,SAAU8D,QAExD,CAACD,EAAQC,EAAQH,IAGlB,cAAC,EAAD,CAAMhG,MAAOA,EAAO2E,OAAQwB,EAAQvB,OAAQA,EAAQR,QAASA,OCpB3DgC,GACJ,UAAAR,EAAOS,MAAK,SAAAC,GAAK,OAAIA,EAAMT,MAAQH,YAAnC,eAAoDpE,OAAQ,GACxDiF,IAAa,UAAAX,EAAOS,MAAK,SAAAC,GAAK,OAAIA,EAAMT,MAAQF,YAAnC,eAAmDrE,OAAQ,GAKxEkF,GAAkB,CAACJ,EAAYG,ICRxBE,GAAkB,WAC7B,IAAMT,EAAWjC,IACXK,EAAUH,GACd,SAAAb,GAAK,OAAIA,EAAMlB,MAAMQ,eAAiB1D,EAAcmE,WAEtD,EAAsCzC,mBAAS,IAA/C,mBAAOgG,EAAP,KAAoBC,EAApB,KACMC,EAAUC,cACVjG,EAAWC,cAOjBC,qBAAU,WACR,IAAgBa,EDAU,SAACX,GAAmC,IAAD,EAOnD,EALZ,IAA+B,UAAC8F,YAAU9F,EAAU,CAClDM,KAAMkF,YADuB,aAAC,EAE5BO,SAA0B,CAAEb,YAAQc,EAAWb,YAAQa,IAFnDd,cAAR,WAAiBc,EAAjB,EAKA,OAAId,EAIK,CAAEA,SAAQC,SAHE,UAACW,YAAU9F,EAAU,CACtCM,KAAMiF,YADW,aAAC,EAEhBQ,SAA0B,CAAEb,YAAQc,EAAWb,YAAQa,IAFnDb,QAKH,CAAED,SAAQC,YAAQa,GCbMC,CAAerG,EAASI,UAA7CkF,OACJvE,IACFqE,EAASvE,EAAWE,IACpBgF,EAAehF,MAEhB,CAACf,EAAUoF,IAQd,OACE,cAAC,GAAD,CACEkB,SArBiB,SAACC,GAEpBP,EAAQpF,KAAR,UAAgBhB,EAAhB,YAA6B2G,KAoB3B/C,QAASA,EACT8B,OAAQQ,EACRU,SAX4B,SAC9BC,GAEAV,EAAeU,EAAMC,OAAOH,W,gDCPnBI,I,OAAS,SAAC,GAKH,IAJlBL,EAIiB,EAJjBA,SACAhB,EAGiB,EAHjBA,OACA9B,EAEiB,EAFjBA,QACAgD,EACiB,EADjBA,SAEA,OACE,cAAC,IAAOG,OAAR,UACE,eAAC,KAAD,CAAKC,QAAQ,QAAQC,MAAM,SAASC,OAAQ,GAA5C,UACE,cAAC,KAAD,CAAKC,KAAM,EAAX,SACE,cAAC,KAAD,CAAKH,QAAQ,QAAQC,MAAM,SAA3B,SACE,eAAC,KAAD,CAAOA,MAAM,SAAb,UACE,cAAC,IAAD,CAAM3H,GAAG,IAAT,SACE,cAAC8H,GAAA,EAAD,CACEjI,MAAO,CAAE6F,SAAU,OAAQvF,MAAO,OAAQ4H,QAAS,aAGvD,cAAC,KAAMC,OAAP,CACEC,YAAY,oBACZpI,MAAO,CAAEkI,QAAS,SAClBzD,QAASA,EACT+C,MAAOjB,EACPgB,SAAUA,EACVE,SAAUA,WAKlB,cAAC,KAAD,CAAKO,KAAM,GAAX,SACE,cAAC,KAAD,CAAKH,QAAQ,QAAQC,MAAM,SAA3B,SACE,qBAAKzC,UAAU,SAAf,SACE,cAAC,KAAD,CAAOyC,MAAM,SAAb,SACE,cAAC,EAAD,mBCzDT,SAASO,KACd,OACE,eAAC,IAAD,CAAQrI,MAAO,CAAEsI,UAAW,SAA5B,UACE,cAAC,GAAD,IACA,cAAC,IAAOC,QAAR,CAAgBvI,MAAO,CAAEwI,QAAS,aAAlC,SACE,cAAC,GAAD,CAAmBC,OAAQxC,MAE7B,cAAC,IAAOyC,OAAR,CACE1I,MAAO,CAAE2I,UAAW,SAAUC,SAAU,SAAUC,OAAQ,KAD5D,6ECNN,IAAMC,GAAqB,SAACnC,GAC1B,OACE,cAAC,IAAD,CACEhF,KAAMgF,EAAMhF,KACZwE,MAAOQ,EAAMR,MACb4C,OAAQ,SAAApJ,GAAK,OAAI,cAACgH,EAAMP,UAAP,2BAAqBzG,GAArB,IAA4B8I,OAAQ9B,EAAM8B,cAWpDO,GAAoB,SAAC,GAA0C,IAAxCP,EAAuC,EAAvCA,OAClC,OACE,eAAC,IAAD,WACGA,EAAOjI,KAAI,SAACmG,EAAO/E,GAClB,OAAO,cAAC,GAAD,eAAwB+E,OAEjC,cAAC,IAAD,CAAOP,UAAW,kBAAM,wDC3BjB6C,GAAQC,YAAe,CAClC/E,QAAS,CACP5B,SAEF4G,UAAU,I,OCCZC,IAASL,OACP,cAAC,IAAMM,WAAP,UACE,cAAC,IAAD,CAAUJ,MAAOA,GAAjB,SACE,cAAC,IAAD,UACE,cAAC,GAAD,UAINK,SAASC,eAAe,W","file":"static/js/main.3d402e3e.chunk.js","sourcesContent":["/**\n * Repository info\n * @typedef Repo\n * @type {object}\n * @property {string} full_name - full name of repository (use as local link)\n * @property {string} name -  repository name\n * @property {string} description - repository description\n */\nexport type Repo = {\n  full_name: string\n  name: string\n  description: string\n}\n\nexport enum LoadingStatus {\n  idle = 'idle',\n  pending = 'pending',\n  succeeded = 'succeeded',\n  failed = 'failed'\n}\n\nexport enum RepoContetItemType {\n  dir = 'dir',\n  file = 'file'\n}\n\n/**\n * Repository cintent item\n * @typedef RepoContent\n * @type {object}\n * @property {string} name - item name (file or folder name)\n * @property {RepoContetItem} type -  item type\n */\nexport type RepoContent = {\n  name: string\n  type: RepoContetItemType\n}\n\n/**\n * Repository readme file\n * @typedef RepoReadme\n * @type {object}\n * @property {string} name - readme file name(should be \"README.md\")\n * @property {RepoContetItem} type -  item type(should be \"file\")\n * @property {string} content -  repo readme content (should be encoded base64)\n * @property {string} encoding -  repo readme encoding (should be \"base64\")\n */\nexport type RepoReadme = {\n  name: string\n  type: RepoContetItemType\n  content: string\n  encoding: string\n}\n\n/**\n * Repository state\n * @typedef ReposState\n * @type {object}\n * @property {LoadingStatus} loading - Loading status\n * @property {string} error -  error message for fetching repositories\n * @property {Repo[]} repos - repositories list for current user\n * @property {LoadingStatus} readmeLoading - readme file loading status\n * @property {string} repoReadme - repository readme\n */\nexport interface ReposState {\n  reposLoading: LoadingStatus\n  error?: string\n  repos: Repo[]\n  repoContent: RepoContent[]\n  repoLoading?: LoadingStatus\n  readmeLoading?: LoadingStatus\n  repoReadme?: string\n}\n\nexport const initialState: ReposState = {\n  reposLoading: LoadingStatus.idle,\n  repoLoading: LoadingStatus.idle,\n  readmeLoading: LoadingStatus.idle,\n  repos: [] as Repo[],\n  repoContent: [] as RepoContent[],\n  repoReadme: ''\n}\n","import React from 'react'\nimport { Card, Typography, Divider } from 'antd'\nimport { Link } from 'react-router-dom'\n\n/**\n * Interface for RepoCard component\n * @typedef CardProps\n * @type {object}\n * @param {string} name - repository\n * @param {string} description - repository description\n * @param {string} link - local link to reposytory page\n */\ninterface CardProps {\n  name?: string\n  link?: string\n  description?: string\n}\n\nconst { Title, Text } = Typography\n\n/**\n * Show reposytory info. Link and description\n */\nexport const RepoCard = (props: CardProps): JSX.Element => {\n  const { name = '', description = '', link = '' } = props\n  return (\n    <Card bordered={false} style={{ width: '100%' }}>\n      <Title level={4}>\n        <Link to={link}>{name}</Link>\n      </Title>\n      <Text>{description}</Text>\n      <Divider />\n    </Card>\n  )\n}\n","import React from 'react'\nimport { Link } from 'react-router-dom'\nimport { Breadcrumb } from 'antd'\n\n/**\n * Interface for Breadcrumbs component\n * @typedef BreadcrumbsItem\n * @type {object}\n * @property {string} href - link of breadcrumb item\n * @property {string} title - title of breacrumb item\n */\nexport type BreadcrumbsItem = {\n  href: string\n  title: string\n}\n\ninterface BreadcrumbsProps {\n  items: BreadcrumbsItem[]\n}\n\n/**\n * Breadcrumbs presentation component\n * Draw passed array of items\n */\nexport const Breadcrumbs = ({ items }: BreadcrumbsProps): JSX.Element => {\n  return (\n    <Breadcrumb style={{ color: '#fff' }}>\n      {items.length &&\n        items.map(item => (\n          <Breadcrumb.Item key={item.href + item.title}>\n            <Link to={item.href}>{item.title}</Link>\n          </Breadcrumb.Item>\n        ))}\n    </Breadcrumb>\n  )\n}\n","/**\n * Root route. If we start application non from root domain address\n * i.e non from http://mydomain.com but from http://mydomain.com/someroute\n * we should pick route \"someroute\" here.\n * For example using GitHub pages location dem is:\n * https://ip4422.github.io/public-repo-show\n * In this case ROOT_ROUTE will be \"/public-repo-show\"\n *\n */\nexport const ROOT_PATH = '/public-repo-show'\n","import React, { useEffect, useState } from 'react'\nimport { useLocation } from 'react-router-dom'\nimport { Breadcrumbs, BreadcrumbsItem } from './'\n\nimport { ROOT_PATH } from '@root/config/constants'\n\n/**\n * BreadcrumbsContainer responsibility for preparing breadcrumbs items\n * on location change\n */\nexport const BreadcrumbsContainer = (): JSX.Element => {\n  const [items, setItems] = useState([] as BreadcrumbsItem[])\n  let location = useLocation()\n\n  useEffect(() => {\n    const pathes = location.pathname.split('/').filter(item => item !== '')\n    let pointer = 0\n    const breadcrumbsItems: BreadcrumbsItem[] = [] as BreadcrumbsItem[]\n    // should consider additional ROOT_PATH for every breadcrumb\n    if (ROOT_PATH && `/${pathes[pointer]}` === ROOT_PATH) {\n      pathes.shift()\n    }\n    while (pointer < pathes.length) {\n      let path = ROOT_PATH ? ROOT_PATH : ''\n      for (let i = 0; i <= pointer; i++) {\n        path += '/' + pathes[i]\n      }\n      breadcrumbsItems.push({\n        href: path,\n        title: pathes[pointer]\n      })\n      pointer++\n    }\n    setItems(breadcrumbsItems)\n  }, [location])\n\n  return <Breadcrumbs items={items} />\n}\n","import { createAsyncThunk } from '@reduxjs/toolkit'\nimport { Repo, RepoContent, RepoReadme } from './types'\n\n/**\n * Asunc fetch repositories action creator\n * @param {string} userName - User name\n * @fulfilled {Repo[]} - Repo list for picked userName\n * @rejected {string} - Error message\n *\n */\nexport const fetchRepos = createAsyncThunk<\n  Repo[],\n  string,\n  {\n    rejectValue: string\n  }\n>(\n  'public-repo-show/repos/fetchRepos',\n  async (userName, { rejectWithValue }) => {\n    const response = await fetch(\n      `https://api.github.com/users/${userName}/repos`\n    )\n    if (response.status === 200) {\n      const repos = await response.json()\n      return repos\n    }\n    return rejectWithValue((await response.json()).message)\n  }\n)\n\n/**\n * Asunc fetch repository content action creator\n * @param {string, string} userName, repoName - User name\n * @fulfilled {RepoContent[]} - Repo list for picked userName\n * @rejected {string} - Error message\n *\n */\nexport const fetchRepoContent = createAsyncThunk<\n  RepoContent[],\n  { userName: string; repoName: string },\n  {\n    rejectValue: string\n  }\n>(\n  'public-repo-show/repos/fetchRepoContent',\n  async ({ userName, repoName }, { rejectWithValue }) => {\n    const response = await fetch(\n      `https://api.github.com/repos/${userName}/${repoName}/contents`\n    )\n    if (response.status === 200) {\n      const repoContent = await response.json()\n      return repoContent\n    }\n    return rejectWithValue((await response.json()).message)\n  }\n)\n\n/**\n * Asunc fetch repository content action creator\n * @param {string, string} userName, repoName - User name\n * @fulfilled {RepoContent[]} - Repo list for picked userName\n * @rejected {string} - Error message\n *\n */\nexport const fetchRepoReadme = createAsyncThunk<\n  RepoReadme,\n  { userName: string; repoName: string },\n  {\n    rejectValue: string\n  }\n>(\n  'public-repo-show/repos/fetchRepoReadme',\n  async ({ userName, repoName }, { rejectWithValue }) => {\n    const response = await fetch(\n      `https://api.github.com/repos/${userName}/${repoName}/readme`\n    )\n    if (response.status === 200) {\n      const repoReadme = await response.json()\n      return repoReadme\n    }\n    return rejectWithValue((await response.json()).message)\n  }\n)\n","import { createSlice } from '@reduxjs/toolkit'\nimport { fetchRepos, fetchRepoContent, fetchRepoReadme } from './reposActions'\nimport { Repo, LoadingStatus, RepoContent, initialState } from './types'\n\nconst counterSlice = createSlice({\n  name: 'public-repo-show/repos',\n  initialState,\n  reducers: {},\n  extraReducers: builder => {\n    builder\n      // Repositories list actions\n      // pending for repositories\n      .addCase(fetchRepos.pending, state => {\n        state.reposLoading = LoadingStatus.pending\n      })\n      // repositories succesfully loaded and passed to reducer\n      .addCase(fetchRepos.fulfilled, (state, action) => {\n        state.reposLoading = LoadingStatus.succeeded\n        state.repos = action.payload || ([] as Repo[])\n      })\n      // some error occurred while loading repositories\n      .addCase(fetchRepos.rejected, (state, action) => {\n        state.error = action?.payload || ''\n        state.repos = [] as Repo[]\n        state.reposLoading = LoadingStatus.failed\n      })\n      // Repository content actions\n      // pending for repository content\n      .addCase(fetchRepoContent.pending, state => {\n        state.repoLoading = LoadingStatus.pending\n      })\n      // repository content succesfully loaded and passed to reducer\n      .addCase(fetchRepoContent.fulfilled, (state, action) => {\n        state.repoLoading = LoadingStatus.succeeded\n        state.repoContent = action.payload || ([] as RepoContent[])\n      })\n      // some error occurred while loading repository content\n      .addCase(fetchRepoContent.rejected, (state, action) => {\n        state.error = action?.payload || ''\n        state.repoContent = [] as RepoContent[]\n        state.repoLoading = LoadingStatus.failed\n      })\n      // Repository readme file actions\n      // pending for repository readme file\n      .addCase(fetchRepoReadme.pending, state => {\n        state.readmeLoading = LoadingStatus.pending\n      })\n      // repository readme file succesfully loaded and passed to reducer\n      .addCase(fetchRepoReadme.fulfilled, (state, action) => {\n        state.readmeLoading = LoadingStatus.succeeded\n        state.repoReadme = atob(action.payload.content || '')\n      })\n      // some error occurred while loading repository readme file\n      .addCase(fetchRepoReadme.rejected, (state, action) => {\n        state.error = action?.payload || ''\n        state.repoReadme = ''\n        state.readmeLoading = LoadingStatus.failed\n      })\n  }\n})\n\nexport const repos = counterSlice.reducer\nexport * from './reposActions'\nexport * from './types'\n","import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux'\nimport type { RootState, AppDispatch } from '../app/store'\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>()\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector","import React from 'react'\nimport { Empty, Spin } from 'antd'\n\nimport { Repo } from '@root/store'\nimport { RepoCard } from '@root/components'\n\n/**\n * Interface for RepoList component\n * @typedef RepoListProps\n * @type {object}\n * @param {Repo[]} repos - array of repositories info\n * @param {string} loading - loading flag\n */\ninterface RepoListProps {\n  repos: Repo[]\n  loading: boolean\n}\n\n/**\n * List or repositories names and descripsions with links to its content\n */\nexport const RepoList = ({\n  repos = [],\n  loading = false\n}: RepoListProps): JSX.Element => {\n  return (\n    <Spin tip='Loading...' spinning={loading}>\n      {repos.length ? (\n        repos.map(repo => (\n          <RepoCard\n            key={`key-for-${repo.full_name}`}\n            name={repo.name}\n            link={repo.full_name}\n            description={repo.description}\n          />\n        ))\n      ) : (\n        <Empty description={<span>Not found</span>} />\n      )}\n    </Spin>\n  )\n}\n","import React from 'react'\n\nimport { RepoList } from './'\nimport { LoadingStatus } from '@root/store'\nimport { useAppSelector } from '@root/utils/hooks'\n\n/**\n * Preparing repository list for presentational component\n */\nexport const RepoListContainer = () => {\n  const repos = useAppSelector(state => state.repos.repos || [])\n  const loading = useAppSelector(\n    state =>\n      state.repos.reposLoading === LoadingStatus.pending ||\n      state.repos.repoLoading === LoadingStatus.pending ||\n      state.repos.readmeLoading === LoadingStatus.pending\n  )\n\n  return <RepoList repos={repos} loading={loading} />\n}\n","import React from 'react'\nimport { List, Typography, Card, Empty, Spin } from 'antd'\nimport ReactMarkdown from 'react-markdown'\nimport './repo.css'\n\nimport { RepoContent } from '@root/store'\nimport { RepoItem } from './'\n\n/**\n * Interface for Repo component\n * @typedef RepoProps\n * @type {object}\n * @param {string} header - repository name\n * @param {string} readme - readme formatted content\n * @param {string} loading - loading flag\n * @param {RepoContent[]} items - repository content files and folder names\n * with content type flag ('file' | 'dir')\n */\ninterface RepoProps {\n  header?: string\n  items: RepoContent[]\n  readme: string\n  loading?: boolean\n}\n\n/**\n * Draw repository content and readme content\n */\nexport const Repo = ({\n  items = [],\n  header = '',\n  readme = '',\n  loading = false\n}: RepoProps): JSX.Element => {\n  return (\n    <Spin tip='Loading...' spinning={loading}>\n      {items.length ? (\n        <>\n          <List\n            size='small'\n            header={<Typography.Title level={4}>{header}</Typography.Title>}\n            bordered\n            dataSource={items}\n            renderItem={item => <RepoItem {...item} />}\n          />\n          <div className='card-wrapper'>\n            <Card title='REAMDE.md'>\n              <ReactMarkdown children={readme} />\n            </Card>\n          </div>\n        </>\n      ) : (\n        <Empty description={<span>Not found</span>} />\n      )}\n    </Spin>\n  )\n}\n","import React from 'react'\nimport { List } from 'antd'\nimport { FolderFilled, FileOutlined } from '@ant-design/icons'\n\nimport { RepoContent, RepoContetItemType } from '@root/store'\n\n/**\n * Item of repository content  with file or folder icon depends on item type\n */\nexport const RepoItem = ({ name, type }: RepoContent): JSX.Element => {\n  return (\n    <List.Item>\n      <List.Item.Meta\n        avatar={\n          type === RepoContetItemType.dir ? (\n            <FolderFilled style={{ color: '#79b8ff', fontSize: '16px' }} />\n          ) : (\n            <FileOutlined style={{ color: '#959da5', fontSize: '16px' }} />\n          )\n        }\n        description={name}\n      />\n    </List.Item>\n  )\n}\n","import { RepoListContainer } from '../pages'\nimport { RepoContainer } from '../pages'\nimport { ROOT_PATH } from './constants'\n\nexport const REPOS_ROOT_KEY = 'REPOS_ROOT_KEY'\nexport const REPO_PAGE_KEY = 'REPO_PAGE_KEY'\n\n/**\n * @typedef RouteItem\n * @type {object}\n * @property {string} path - the route thatâ€™s handled by this config\n * @property {string} key -  a unique identifier for the route\n * @property {boolean} exact - a bool that determines whether the path should\n * be matched for exactly, or just partially\n * @property {JSX.Element} component - the component to render when the app is\n * at the particular path\n */\nexport type RouteItem = {\n  path: string\n  key: string\n  exact?: boolean\n  component: <T>(props: T) => JSX.Element\n  routes?: RouteItem[]\n}\n\n/**\n * Interface for Routes component\n * @typedef RoutesProps\n * @type {object}\n * @property {RouteItem[]} routes - routes to render\n */\nexport interface RoutesProps {\n  routes: RouteItem[]\n}\n\n/**\n *  All application routes\n * @type {RouteItem[]}\n */\nexport const ROUTES: RouteItem[] = [\n  {\n    path: `${ROOT_PATH}/`,\n    key: 'APP_ROOT',\n    exact: true,\n    component: RepoListContainer\n  },\n  {\n    path: `${ROOT_PATH}/:userId`,\n    exact: true,\n    key: REPOS_ROOT_KEY,\n    component: RepoListContainer\n  },\n  {\n    path: `${ROOT_PATH}/:userId/:repoId`,\n    exact: true,\n    key: REPO_PAGE_KEY,\n    component: RepoContainer\n  }\n]\n","import React, { useEffect } from 'react'\nimport { useParams } from 'react-router-dom'\n\nimport { fetchRepoContent, fetchRepoReadme, LoadingStatus } from '@root/store'\nimport { RepoContent } from '@root/store'\nimport { useAppSelector, useAppDispatch } from '@root/utils/hooks'\nimport { Repo } from './'\nimport { RouteParams } from '@root/helpers'\n\n/**\n * Preparing repository content and readme content. Fetch repository content\n * and readme content on route change\n */\nexport const RepoContainer = () => {\n  const dispatch = useAppDispatch()\n  const items = useAppSelector(\n    state => state.repos.repoContent || ([] as RepoContent[])\n  )\n  const loading = useAppSelector(\n    state =>\n      state.repos.reposLoading === LoadingStatus.pending ||\n      state.repos.repoLoading === LoadingStatus.pending ||\n      state.repos.readmeLoading === LoadingStatus.pending\n  )\n  const readme = useAppSelector(state => state.repos.repoReadme || '')\n  let { userId, repoId } = useParams() as RouteParams\n\n  useEffect(() => {\n    if (userId && repoId) {\n      dispatch(fetchRepoContent({ userName: userId, repoName: repoId }))\n      dispatch(fetchRepoReadme({ userName: userId, repoName: repoId }))\n    }\n  }, [userId, repoId, dispatch])\n\n  return (\n    <Repo items={items} header={repoId} readme={readme} loading={loading} />\n  )\n}\n","import { matchPath } from 'react-router-dom'\nimport { ROUTES, REPO_PAGE_KEY, REPOS_ROOT_KEY } from '@root/config/routes'\n\n/**\n * All known params for application routes\n * @typedef RoutesParams\n * @type {object}\n * @property {string} userId - current userId\n * @property {string} repoId -  current repoId\n */\nexport type RouteParams = {\n  userId?: string\n  repoId?: string\n}\n\nconst userIdPath =\n  ROUTES.find(route => route.key === REPOS_ROOT_KEY)?.path || ''\nconst repoIdPath = ROUTES.find(route => route.key === REPO_PAGE_KEY)?.path || ''\n/**\n * List of all possible routes params for parsing on app initialization\n * to fetch data if we starts from some known route\n */\nconst allRoutesToList = [userIdPath, repoIdPath]\n\n/**\n * Parsing route params\n * @param {string} pathname - current location pathname (current route)\n * @returns {RouteParams} - all params for current route\n */\nexport const getRouteParams = (pathname: string): RouteParams => {\n  // check for userId first. We can repform on routes\n  const { userId = undefined } = (matchPath(pathname, {\n    path: allRoutesToList\n  })?.params as RouteParams) || { userId: undefined, repoId: undefined }\n\n  // if we have userId than can exist repoId\n  if (userId) {\n    const { repoId } = (matchPath(pathname, {\n      path: repoIdPath\n    })?.params as RouteParams) || { userId: undefined, repoId: undefined }\n    return { userId, repoId }\n  }\n  return { userId, repoId: undefined }\n}\n","import React, { useState, useEffect } from 'react'\nimport { useHistory, useLocation } from 'react-router-dom'\n\nimport { fetchRepos, LoadingStatus } from '@root/store'\nimport { useAppDispatch, useAppSelector } from '@root/utils/hooks'\nimport { Header } from './'\nimport { getRouteParams } from '@root/helpers'\nimport { ROOT_PATH } from '@root/config/constants'\n\n/**\n * Container component for Header\n * responsible for parsing path and pass it to children userId and\n * onChange, onSearch handlers\n */\nexport const HeaderContainer = (): JSX.Element => {\n  const dispatch = useAppDispatch()\n  const loading = useAppSelector(\n    state => state.repos.reposLoading === LoadingStatus.pending\n  )\n  const [searchValue, setSearchValue] = useState('')\n  const history = useHistory()\n  const location = useLocation()\n\n  const handleSearch = (value: string) => {\n    // fetch dispatched on location change\n    history.push(`${ROOT_PATH}/${value}`)\n  }\n\n  useEffect(() => {\n    const { userId: userName } = getRouteParams(location.pathname)\n    if (userName) {\n      dispatch(fetchRepos(userName))\n      setSearchValue(userName)\n    }\n  }, [location, dispatch])\n\n  const handleChangeSearchValue = (\n    event: React.ChangeEvent<HTMLInputElement>\n  ) => {\n    setSearchValue(event.target.value)\n  }\n\n  return (\n    <Header\n      onSearch={handleSearch}\n      loading={loading}\n      userId={searchValue}\n      onChange={handleChangeSearchValue}\n    />\n  )\n}\n","import React from 'react'\nimport { Layout, Row, Col, Input, Space } from 'antd'\nimport { GithubOutlined } from '@ant-design/icons'\nimport { Link } from 'react-router-dom'\nimport './header.css'\n\nimport { BreadcrumbsContainer } from '../'\n\n/**\n * Interface for Header component\n * @typedef HeaderProps\n * @type {object}\n * @property {string} userId - userId for search input\n * @property {boolean} loading - loading flag\n * @property {function} onSearch - handling search event for fetch repos\n * @property {function} onChange - handling change event for storing userId\n *\n */\ninterface HeaderProps {\n  onSearch: (value: string) => void\n  userId?: string\n  loading?: boolean\n  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void\n}\n\n/**\n * Show Header with search input and breadcrumbs\n * @param {function} onSearch - handler for userId repo list fetching\n * @param {string} userId - user for repositories list\n * @param {boolean} loading - loading flag\n * @param {function} onChange - handler for storing userId value\n */\nexport const Header = ({\n  onSearch,\n  userId,\n  loading,\n  onChange\n}: HeaderProps) => {\n  return (\n    <Layout.Header>\n      <Row justify='start' align='middle' gutter={32}>\n        <Col span={4}>\n          <Row justify='start' align='middle'>\n            <Space align='center'>\n              <Link to='/'>\n                <GithubOutlined\n                  style={{ fontSize: '32px', color: '#fff', display: 'block' }}\n                />\n              </Link>\n              <Input.Search\n                placeholder=\"Github's username\"\n                style={{ display: 'block' }}\n                loading={loading}\n                value={userId}\n                onSearch={onSearch}\n                onChange={onChange}\n              />\n            </Space>\n          </Row>\n        </Col>\n        <Col span={12}>\n          <Row justify='start' align='middle'>\n            <div className='header'>\n              <Space align='center'>\n                <BreadcrumbsContainer />\n              </Space>\n            </div>\n          </Row>\n        </Col>\n      </Row>\n    </Layout.Header>\n  )\n}\n","import React from 'react'\nimport './App.less'\nimport { Layout } from 'antd'\n\nimport { HeaderContainer } from '../components'\nimport { ROUTES, ApplicationRoutes } from './'\n\nexport function App() {\n  return (\n    <Layout style={{ minHeight: '100vh' }}>\n      <HeaderContainer />\n      <Layout.Content style={{ padding: '20px 50px' }}>\n        <ApplicationRoutes routes={ROUTES} />\n      </Layout.Content>\n      <Layout.Footer\n        style={{ textAlign: 'center', position: 'sticky', bottom: '0' }}\n      >\n        Application for displaying Github user's public repositories\n      </Layout.Footer>\n    </Layout>\n  )\n}\n","import React from 'react'\nimport { Route, Switch } from 'react-router-dom' // <-- New code\nimport { RouteItem, RoutesProps } from '../config/routes'\n/**\n * Render a route with potential sub routes\n * @param {RouteItem} route - Route with potential sub routes.\n * @returns {JSX.Element} - Route (react-router-dom component)\n */\nconst RouteWithSubRoutes = (route: RouteItem): JSX.Element => {\n  return (\n    <Route\n      path={route.path}\n      exact={route.exact}\n      render={props => <route.component {...props} routes={route.routes} />}\n    />\n  )\n}\n\n/**\n * Render all array of routes with potential sub routes\n * @param {RouteItem} route - Route with potential sub routes.\n * @returns {JSX.Element} - All Routes wrapped in Switch (react-router-dom\n * component)\n */\nexport const ApplicationRoutes = ({ routes }: RoutesProps): JSX.Element => {\n  return (\n    <Switch>\n      {routes.map((route, i) => {\n        return <RouteWithSubRoutes {...route} />\n      })}\n      <Route component={() => <h1>Page Not Found!</h1>} />\n    </Switch>\n  )\n}\n\nexport * from '../config/routes'\n","import { configureStore } from '@reduxjs/toolkit'\nimport { repos } from '../store'\n\nexport const store = configureStore({\n  reducer: {\n    repos\n  },\n  devTools: true\n})\n\n// Infer the `RootState` type from the store\nexport type RootState = ReturnType<typeof store.getState>\n// Inferred type: {repos: ReposState}\nexport type AppDispatch = typeof store.dispatch\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport { BrowserRouter as Router } from 'react-router-dom'\nimport { Provider } from 'react-redux'\nimport { store } from './app'\n\nimport './index.css'\nimport { App } from './app'\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <Router>\n        <App />\n      </Router>\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n"],"sourceRoot":""}